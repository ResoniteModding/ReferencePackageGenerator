name: Generate Reference Package

on:
  workflow_dispatch:
    inputs:
      build_version:
        description: "Build version from Resonite (optional, uses Build.version if not provided)"
        required: false
        type: string
      branch:
        description: "Branch to process"
        required: false
        default: "public"
        type: string
      publish:
        description: "publish to nuget"
        required: false
        default: false
        type: boolean
  schedule:
    - cron: "*/10 * * * *"

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      attestations: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          persist-credentials: false

      - name: Setup .NET
        uses: actions/setup-dotnet@baa11fbfe1d6520db94683bd5c7a3818018e4309 # v5.1.0
        with:
          dotnet-version: "10.0.x"

      - name: Download Resonite Assemblies
        uses: hazre/resonite-download-action@4e0e86949c85f22a0a2bcc789881f4da7ae0a821 # v1.0.0
        with:
          steam-username: ${{ secrets.STEAM_USERNAME }}
          steam-password: ${{ secrets.STEAM_PASSWORD }}
          resonite-path: resonite-assemblies
          branch: ${{ github.event.inputs.branch || 'public' }}

      - name: Resolve Build Metadata
        env:
          INPUT_BUILD_VERSION: ${{ github.event.inputs.build_version }}
          INPUT_BRANCH: ${{ github.event.inputs.branch || 'public' }}
        run: |
          # Prefer explicit input version for manual runs, otherwise read from Build.version
          if [ -n "${INPUT_BUILD_VERSION:-}" ]; then
            version="$INPUT_BUILD_VERSION"
            echo "Using provided build_version input: $version"
          else
            version_file="resonite-assemblies/Build.version"
            if [ -f "$version_file" ]; then
              version=$(cat "$version_file" | tr -d '\r\n')
              echo "Read version from Build.version: $version"
            else
              echo "Error: No build_version provided and Build.version not found"
              exit 1
            fi
          fi

          branch="${INPUT_BRANCH:-public}"
          echo "Processing branch: $branch"

          if [ "$branch" != "public" ]; then
            sanitized_branch=$(echo "$branch" | sed 's/[^a-zA-Z0-9-]/-/g')
            version="${version}-${sanitized_branch}"
            echo "Appended branch name to version for prerelease"
          fi

          package_name=$(jq -r '.PackageIdPrefix + .SinglePackageName' Resonite.json)
          if [ -z "$package_name" ] || [ "$package_name" = "null" ]; then
            echo "Error: Could not derive package name from Resonite.json"
            exit 1
          fi

          echo "Using version: $version"
          echo "Resolved package name: $package_name"
          echo "BUILD_VERSION=$version" >> $GITHUB_ENV
          echo "PACKAGE_NAME=$package_name" >> $GITHUB_ENV

      - name: Check NuGet for Existing Version
        run: |
          package_id_lower=$(echo "$PACKAGE_NAME" | tr '[:upper:]' '[:lower:]')
          version_lower=$(echo "$BUILD_VERSION" | tr '[:upper:]' '[:lower:]')
          index_url="https://api.nuget.org/v3-flatcontainer/${package_id_lower}/index.json"

          echo "Checking NuGet for ${PACKAGE_NAME} ${BUILD_VERSION}"

          if curl -fsSL "$index_url" | jq -e --arg v "$version_lower" '.versions | map(ascii_downcase) | index($v) != null' > /dev/null; then
            echo "Version already exists on NuGet. Marking workflow for early skip."
            echo "SKIP_WORKFLOW=true" >> $GITHUB_ENV
          else
            echo "Version not published yet. Continuing workflow."
            echo "SKIP_WORKFLOW=false" >> $GITHUB_ENV
          fi

      - name: Early Exit (Already Published)
        if: env.SKIP_WORKFLOW == 'true'
        run: echo "Skipping package generation because this version is already published to NuGet."

      - name: Clone Elements.Quantity from source
        if: env.SKIP_WORKFLOW != 'true'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          repository: hazre/Elements.Quantity
          ref: 3965e9f686c271758d4de3431d550b189b185dd2 # main
          path: elements-quantity
          persist-credentials: false

      - name: Build Elements.Quantity
        if: env.SKIP_WORKFLOW != 'true'
        run: |
          cd elements-quantity
          dotnet build -c Release
          echo "Elements.Quantity built successfully"

      - name: Replace Elements.Quantity DLLs and PDBs
        if: env.SKIP_WORKFLOW != 'true'
        run: |
          echo "Finding built Elements.Quantity files..."
          built_dll=$(find elements-quantity -name "Elements.Quantity.dll" -path "*/bin/Release/*" | head -1)
          built_pdb=$(find elements-quantity -name "Elements.Quantity.pdb" -path "*/bin/Release/*" | head -1)

          if [ -z "$built_dll" ]; then
            echo "Error: Could not find built Elements.Quantity.dll"
            exit 1
          fi

          echo "Found built DLL at: $built_dll"

          if [ -n "$built_pdb" ]; then
            echo "Found built PDB at: $built_pdb"
          else
            echo "Warning: Could not find Elements.Quantity.pdb"
          fi

          # Find and replace all Elements.Quantity.dll files in resonite-assemblies
          find resonite-assemblies -name "Elements.Quantity.dll" -type f | while read -r dll_path; do
            echo "Replacing DLL: $dll_path"
            cp "$built_dll" "$dll_path"

            # If PDB exists, copy it to the same directory as the DLL
            if [ -n "$built_pdb" ]; then
              pdb_dest="$(dirname "$dll_path")/Elements.Quantity.pdb"
              echo "Copying PDB to: $pdb_dest"
              cp "$built_pdb" "$pdb_dest"
            fi
          done

          echo "All Elements.Quantity files replaced successfully"

      - name: Prepare Config
        if: env.SKIP_WORKFLOW != 'true'
        env:
          BUILD_VERSION: ${{ env.BUILD_VERSION }}
        run: |
          version="$BUILD_VERSION"

          # Copy and modify the Resonite.json config
          cp Resonite.json resonite-config.json

          # Use jq to update paths and version
          jq --arg sp "${{ github.workspace }}/resonite-assemblies" \
             --arg dp "${{ github.workspace }}/output/dlls" \
             --arg np "${{ github.workspace }}/output/packages" \
             --arg rp "${{ github.workspace }}/ReferencePackageGenerator/README.md" \
             --arg ver "$version" \
             '.SourcePath = $sp |
              .DllTargetPath = $dp |
              .NupkgTargetPath = $np |
              .ReadmePath = $rp |
              .SinglePackageVersion = $ver' \
             resonite-config.json > resonite-config-temp.json

          mv resonite-config-temp.json resonite-config.json

          echo "Config file prepared from Resonite.json"

      - name: Generate Reference Package
        if: env.SKIP_WORKFLOW != 'true'
        run: |
          cd ReferencePackageGenerator
          dotnet run -- "${{ github.workspace }}/resonite-config.json"

      - name: Attest Build Provenance
        if: env.SKIP_WORKFLOW != 'true'
        uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f
        with:
          subject-path: output/packages/${{ env.PACKAGE_NAME }}.nupkg

      - name: Upload Package Artifact
        if: env.SKIP_WORKFLOW != 'true'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: reference-package-${{ env.BUILD_VERSION }}
          path: output/packages/*.nupkg
          retention-days: 30

      - name: Upload DLLs Artifact
        if: env.SKIP_WORKFLOW != 'true'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: stripped-dlls-${{ env.BUILD_VERSION }}
          path: output/dlls/*.dll
          retention-days: 7

      - name: Publish to NuGet
        if: env.SKIP_WORKFLOW != 'true' && (github.event_name == 'schedule' || github.event.inputs.publish == 'true')
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          if [ -n "$NUGET_API_KEY" ]; then
            for package in output/packages/*.nupkg; do
              if [ -f "$package" ]; then
                echo "Publishing $(basename $package) to NuGet..."
                dotnet nuget push "$package" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate
              fi
            done
          else
            echo "Warning: NUGET_API_KEY not set, skipping publish"
          fi
