name: Generate Reference Package

on:
  workflow_dispatch:
    inputs:
      build_version:
        description: 'Build version from Resonite (optional, uses Build.version if not provided)'
        required: false
        type: string
      branch:
        description: 'Branch to process'
        required: false
        default: 'main'
        type: string
      publish:
        description: 'publish to nuget'
        required: false
        default: false
        type: boolean
  repository_dispatch:
    types: [generate-references]

jobs:
  generate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'
          
      - name: Download Resonite Assemblies
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.RESONITE_ASSEMBLIES_REPO }}
          ref: ${{ github.event.inputs.branch || github.event.client_payload.branch || 'main' }}
          path: resonite-assemblies
          token: ${{ secrets.PRIVATE_TOKEN_GITHUB }}
          
      - name: Clone Elements.Quantity from source
        uses: actions/checkout@v4
        with:
          repository: hazre/Elements.Quantity
          ref: remove-utility
          path: elements-quantity
          
      - name: Build Elements.Quantity
        run: |
          cd elements-quantity
          dotnet build -c Release
          echo "Elements.Quantity built successfully"
          
      - name: Replace Elements.Quantity DLLs and PDBs
        run: |
          echo "Finding built Elements.Quantity files..."
          built_dll=$(find elements-quantity -name "Elements.Quantity.dll" -path "*/bin/Release/*" | head -1)
          built_pdb=$(find elements-quantity -name "Elements.Quantity.pdb" -path "*/bin/Release/*" | head -1)
          
          if [ -z "$built_dll" ]; then
            echo "Error: Could not find built Elements.Quantity.dll"
            exit 1
          fi
          
          echo "Found built DLL at: $built_dll"
          
          if [ -n "$built_pdb" ]; then
            echo "Found built PDB at: $built_pdb"
          else
            echo "Warning: Could not find Elements.Quantity.pdb"
          fi
          
          # Find and replace all Elements.Quantity.dll files in resonite-assemblies
          find resonite-assemblies -name "Elements.Quantity.dll" -type f | while read -r dll_path; do
            echo "Replacing DLL: $dll_path"
            cp "$built_dll" "$dll_path"
            
            # If PDB exists, copy it to the same directory as the DLL
            if [ -n "$built_pdb" ]; then
              pdb_dest="$(dirname "$dll_path")/Elements.Quantity.pdb"
              echo "Copying PDB to: $pdb_dest"
              cp "$built_pdb" "$pdb_dest"
            fi
          done
          
          echo "All Elements.Quantity files replaced successfully"
          
      - name: Prepare Config
        run: |
          # Always try to read from Build.version first
          version_file="resonite-assemblies/Build.version"
          if [ -f "$version_file" ]; then
            version=$(cat "$version_file" | tr -d '\r\n')
            echo "Read version from Build.version: $version"
          else
            # Fall back to input parameter if Build.version doesn't exist
            version="${{ github.event.inputs.build_version || github.event.client_payload.build_version }}"
            if [ -z "$version" ]; then
              echo "Error: Build.version not found and no version provided"
              exit 1
            fi
            echo "Using provided version: $version"
          fi
          
          # Get the branch name
          branch="${{ github.event.inputs.branch || github.event.client_payload.branch || 'main' }}"
          echo "Processing branch: $branch"
          
          # Append branch name to version if not main/master
          if [ "$branch" != "main" ] && [ "$branch" != "master" ]; then
            # Sanitize branch name for NuGet (replace invalid chars with -)
            sanitized_branch=$(echo "$branch" | sed 's/[^a-zA-Z0-9-]/-/g')
            version="${version}-${sanitized_branch}"
            echo "Appended branch name to version for prerelease"
          fi
          
          echo "Using version: $version"
          
          # Export version for use in later steps
          echo "BUILD_VERSION=$version" >> $GITHUB_ENV
          
          # Copy and modify the Resonite.json config
          cp Resonite.json resonite-config.json
          
          # Use jq to update paths and version
          jq --arg sp "${{ github.workspace }}/resonite-assemblies" \
             --arg dp "${{ github.workspace }}/output/dlls" \
             --arg np "${{ github.workspace }}/output/packages" \
             --arg rp "${{ github.workspace }}/ReferencePackageGenerator/README.md" \
             --arg ver "$version" \
             '.SourcePath = $sp | 
              .DllTargetPath = $dp | 
              .NupkgTargetPath = $np | 
              .ReadmePath = $rp | 
              .SinglePackageVersion = $ver' \
             resonite-config.json > resonite-config-temp.json
          
          mv resonite-config-temp.json resonite-config.json
          
          echo "Config file prepared from Resonite.json"
          
      - name: Generate Reference Package
        run: |
          cd ReferencePackageGenerator
          dotnet run -- "${{ github.workspace }}/resonite-config.json"
          
      - name: Upload Package Artifact
        uses: actions/upload-artifact@v4
        with:
          name: reference-package-${{ env.BUILD_VERSION }}
          path: output/packages/*.nupkg
          retention-days: 30
          
      - name: Upload DLLs Artifact
        uses: actions/upload-artifact@v4
        with:
          name: stripped-dlls-${{ env.BUILD_VERSION }}
          path: output/dlls/*.dll
          retention-days: 7
          
      - name: Publish to NuGet
        if: github.event.inputs.publish == 'true' || github.event.client_payload.publish == true
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          if [ -n "$NUGET_API_KEY" ]; then
            for package in output/packages/*.nupkg; do
              if [ -f "$package" ]; then
                echo "Publishing $(basename $package) to NuGet..."
                dotnet nuget push "$package" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate
              fi
            done
          else
            echo "Warning: NUGET_API_KEY not set, skipping publish"
          fi
